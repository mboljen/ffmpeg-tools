#!/usr/bin/env bash
#
# Created:         So 2023-08-06 01:34:08 CEST
# Last Modified:   Mo 2023-08-07 09:51:44 CEST
#
# ffmpeg-convert:
#   Convert one or several video files.

# Help text
usage () {
cat << EOF

Usage: ffmpeg-convert [options] <infile> [..]

OPTIONS:
  -c <string>          Set cropdetect to remove black borders (default: auto)
  -o <option> [value]  Set ffmpeg option and value (can be used multiple times)
  -e <ext>             Set file extension of output file (default: mp4)
  -y                   Overwrite existing files
  -h                   Show this help message
EOF
}

# Initialization
FFMPEG=$(command -v ffmpeg)
CROPDETECT=$(command -v ffmpeg-cropdetect)

# Defaults
CROP=
EXT=
YES=
OPTS=()

# Resolve folder where script resides
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

# Parse local and user-defined configuration files
for file in "${SCRIPT_DIR}/../etc/ffmpeg-convert.conf" "${HOME}/.ffmpeg-convert"
do
    if [ -f "$file" ]
    then
        $(confget -c -f "$file" CROP) && CROP=$(confget -nf "$file" CROP)
        $(confget -c -f "$file" OPTS) && OPTS=( $(confget -nf "$file" OPTS) )
        $(confget -c -f "$file" EXT) && EXT=$(confget -nf "$file" EXT)
        $(confget -c -f "$file" YES) && YES=$(confget -nf "$file" YES)
    fi
done

# Flag to mark cleared OPTS array
OPTSCLR=0

# Process options
while getopts "c:o:e:yh" OPTION
do
    case "$OPTION"
    in
        c)  CROP="$OPTARG"
            ;;
        o)  # Check if OPTS array has been cleared; options from command line overwrite
            if [ "$OPTSCLR" -eq 0 ]
            then
                OPTS=()
                OPTSCLR=1
            fi
            OPTS+=("$OPTARG")
            # See if next argument is an option, and, if not,
            # add it to the pass-through array and skip it
            if [[ ${@:OPTIND:1} != -* ]]
            then
                OPTS+=("${@: OPTIND:1}" )
                (( ++OPTIND ))
            fi
            ;;
        e)  EXT="$OPTARG"
            ;;
        y)  YES=1
            ;;
        h)  usage
            exit 0
            ;;
       \?)  usage
            exit 1
            ;;
    esac
done

# Use default crop
if [ -z "${CROP}" ]
then
    CROP=auto
fi

# Use default FFmpeg's options
if [ "${#OPTS[@]}" -eq 0 ]
then
    OPTS=( -map 0:v -map 0:a? -c:v h264 -crf 23 -c:a copy )
fi

# Use default file extension
if [ -z "${EXT}" ]
then
    EXT=mp4
fi

if [ -z "${YES}" ]
then
    YES=0
fi

# Check if ffmpeg is available
if [ ! -x "${FFMPEG}" ]
then
    echo "$0: ffmpeg not found, probably not installed"
    exit 1
fi

# Check if ffmpeg-cropdetect is available
if [ ! -x "${CROPDETECT}" ]
then
    echo "$0: cropdetect is not found, probably not installed"
    exit 1
fi

# Skip options and shift index
shift $((OPTIND-1))

# Check number of arguments
if [ "$#" -eq 0 ]
then
    echo "$0 requires at least 1 argument"
    usage
    exit 1
fi

# For debugging
echo "CROP    = ${CROP}"
echo "OPTS    = ${OPTS[@]}"
echo "EXT     = ${EXT}"
echo "YES     = ${YES}"

# Loop over arguments
while [ $# -gt 0 ]
do

    # Get filename
    INFILE="$1"
    shift

    # Skip file if not existing
    if [ ! -f "${INFILE}" ]
    then
        echo "$0: ${INFILE} is not a valid file, skipped"
        continue
    fi

    # Replace file extension
    OUTFILE="${INFILE%.*}.${EXT}"

    # Rename output file if it matches input filename
    if [ "${OUTFILE}" = "$INFILE" ]
    then
        OUTFILE="${INFILE%.*}-new.${EXT}"
    fi

    echo "INFILE  = ${INFILE}"
    echo "OUTFILE = ${OUTFILE}"

    # Check if output file already exists
    if [ -f "$OUTFILE" ] && [ "${YES}" -eq 0 ]
    then
        echo "Outputfile already exists ... skipped"
        continue
    fi

    # Set crop option
    if [ "${CROP}" = "yes"     ] || \
       [ "${CROP}" = "true"    ] || \
       [ "${CROP}" = "enabled" ] || [ "${CROP}" = "auto" ]
    then
        # Autocrop
        cropopt="-vf $(${CROPDETECT} "${INFILE}")"
        if [ $? -ne 0 ]
        then
            echo "cropdetect failed with error code $?"
            cropout=
        fi
    elif [ "${CROP}" = "no"       ] || \
         [ "${CROP}" = "false"    ] || \
         [ "${CROP}" = "disabled" ] || [ -z "${CROP}" ]
    then
        # No crop
        cropopt=
    else
        # User defined crop
        cropopt="-vf \"${CROP}\""
    fi

    echo "CROPOPT = $cropopt"

    # Invoke FFmpeg
    "${FFMPEG}" -y -i "${INFILE}" $cropopt ${OPTS[@]} "${OUTFILE}"

done
